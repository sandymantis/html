
// Define the DataTable web component
class DataTable extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this._data = [];
    this._filteredData = [];
    this._sortColumn = null;
    this._sortDirection = 'asc';
  }

  static get observedAttributes() {
    return ['columns'];
  }

  connectedCallback() {
    this.render();
    this.addEventListeners();
  }

  set data(value) {
    this._data = value;
    this._filteredData = [...value];
    this.render();
  }

  get data() {
    return this._data;
  }

  addEventListeners() {
    // Filter input handler
    this.shadowRoot.querySelector('.filter-input')?.addEventListener('input', (e) => {
      const filterValue = e.target.value.toLowerCase();
      this._filteredData = this._data.filter(row => 
        Object.values(row).some(value => 
          value.toString().toLowerCase().includes(filterValue)
        )
      );
      this.render();
    });

    // Sort handler for column headers
    this.shadowRoot.querySelector('table')?.addEventListener('click', (e) => {
      const headerCell = e.target.closest('th');
      if (headerCell) {
        const column = headerCell.dataset.column;
        this.sortByColumn(column);
      }
    });
  }

  sortByColumn(column) {
    if (this._sortColumn === column) {
      this._sortDirection = this._sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
      this._sortColumn = column;
      this._sortDirection = 'asc';
    }

    this._filteredData.sort((a, b) => {
      const valueA = a[column];
      const valueB = b[column];
      
      if (typeof valueA === 'string') {
        return this._sortDirection === 'asc' 
          ? valueA.localeCompare(valueB)
          : valueB.localeCompare(valueA);
      }
      
      return this._sortDirection === 'asc' 
        ? valueA - valueB
        : valueB - valueA;
    });

    this.render();
  }

  getStatusClass(status) {
    const statusMap = {
      'Success': 'success',
      'Failed': 'failed',
      'Processing': 'processing'
    };
    return statusMap[status] || '';
  }

  render() {
    const style = `
      <style>
        :host {
          display: block;
          font-family: system-ui, -apple-system, sans-serif;
        }
        
        .container {
          border: 1px solid #e2e8f0;
          border-radius: 8px;
          padding: 16px;
        }

        .header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 16px;
        }

        .filter-input {
          padding: 8px 12px;
          border: 1px solid #e2e8f0;
          border-radius: 6px;
          width: 200px;
        }

        table {
          width: 100%;
          border-collapse: collapse;
        }

        th, td {
          padding: 12px;
          text-align: left;
          border-bottom: 1px solid #e2e8f0;
        }

        th {
          cursor: pointer;
          user-select: none;
        }

        th:hover {
          background-color: #f8fafc;
        }

        .status-cell {
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .status-indicator {
          width: 8px;
          height: 8px;
          border-radius: 50%;
        }

        .success .status-indicator {
          background-color: #22c55e;
        }

        .failed .status-indicator {
          background-color: #ef4444;
        }

        .processing .status-indicator {
          background-color: #3b82f6;
        }

        .amount {
          font-family: monospace;
        }

        .footer {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-top: 16px;
          font-size: 14px;
          color: #64748b;
        }
      </style>
    `;

    const html = `
      <div class="container">
        <div class="header">
          <input type="text" class="filter-input" placeholder="Filter items...">
        </div>
        
        <table>
          <thead>
            <tr>
              <th data-column="status">Status</th>
              <th data-column="email">Email</th>
              <th data-column="amount">Amount</th>
            </tr>
          </thead>
          <tbody>
            ${this._filteredData.map(row => `
              <tr>
                <td>
                  <div class="status-cell ${this.getStatusClass(row.status)}">
                    <span class="status-indicator"></span>
                    ${row.status}
                  </div>
                </td>
                <td>${row.email}</td>
                <td class="amount">$${parseFloat(row.amount).toFixed(2)}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
        
        <div class="footer">
          <span>${this._filteredData.length} of ${this._data.length} row(s)</span>
        </div>
      </div>
    `;

    this.shadowRoot.innerHTML = style + html;
  }
}

// Register the web component
customElements.define('data-table', DataTable);// accordion-component.js
class AccordionComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: block;
          font-family: system-ui, -apple-system, sans-serif;
        }

        .accordion {
          border: 1px solid #e5e7eb;
          border-radius: 4px;
          overflow: hidden;
        }
      </style>
      <div class="accordion">
        <slot></slot>
      </div>
    `;
  }
}

class AccordionItemComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    const title = this.getAttribute('title') || 'Accordion Item';
    const content = this.innerHTML;
    
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: block;
          border-bottom: 1px solid #e5e7eb;
        }

        :host(:last-child) {
          border-bottom: none;
        }

        .accordion-trigger {
          width: 100%;
          padding: 1rem;
          display: flex;
          justify-content: space-between;
          align-items: center;
          background: none;
          border: none;
          cursor: pointer;
          text-align: left;
          font-size: 0.875rem;
          font-weight: 500;
          transition: background-color 0.2s;
        }

        .accordion-trigger:hover {
          text-decoration: underline;
          background-color: #f9fafb;
        }

        .chevron {
          width: 16px;
          height: 16px;
          transition: transform 0.2s;
        }

        .accordion-trigger[aria-expanded="true"] .chevron {
          transform: rotate(180deg);
        }

        .accordion-content {
          height: 0;
          overflow: hidden;
          transition: height 0.3s ease-out;
          padding: 0 1rem;
        }

        .accordion-content.expanded {
          height: auto;
          padding: 1rem;
        }

        .content-inner {
          opacity: 0;
          transition: opacity 0.3s ease-out;
        }

        .content-inner.visible {
          opacity: 1;
        }
      </style>
      <div class="accordion-item">
        <button class="accordion-trigger" aria-expanded="false">
          ${title}
          <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </button>
        <div class="accordion-content">
          <div class="content-inner">
            ${content}
          </div>
        </div>
      </div>
    `;

    this.trigger = this.shadowRoot.querySelector('.accordion-trigger');
    this.content = this.shadowRoot.querySelector('.accordion-content');
    this.contentInner = this.shadowRoot.querySelector('.content-inner');
    
    this.trigger.addEventListener('click', () => this.toggleAccordion());
  }

  toggleAccordion() {
    const isExpanded = this.trigger.getAttribute('aria-expanded') === 'true';
    this.trigger.setAttribute('aria-expanded', !isExpanded);
    
    if (!isExpanded) {
      // Expanding
      this.content.classList.add('expanded');
      this.contentInner.classList.add('visible');
      // Set actual height
      const height = this.contentInner.offsetHeight;
      this.content.style.height = height + 'px';
    } else {
      // Collapsing
      const height = this.content.offsetHeight;
      this.content.style.height = height + 'px';
      // Force reflow
      this.content.offsetHeight;
      this.content.style.height = '0';
      this.contentInner.classList.remove('visible');
      
      // Remove expanded class after transition
      this.content.addEventListener('transitionend', () => {
        if (!isExpanded) return;
        this.content.classList.remove('expanded');
      }, { once: true });
    }
  }
}

// Register the components
customElements.define('custom-accordion', AccordionComponent);
customElements.define('accordion-item', AccordionItemComponent);
