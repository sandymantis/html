class DataTable extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this._data = [];
    this._filteredData = [];
    this._sortColumn = null;
    this._sortDirection = 'asc';
    this._columns = [];
    this.render();
  }

  static get observedAttributes() {
    return ['data'];
  }

  get data() {
    return this._data;
  }

  set data(newData) {
    if (Array.isArray(newData)) {
      this._data = [...newData];
      this._filteredData = [...newData];
      // Extract columns from the first data item
      if (newData.length > 0) {
        this._columns = Object.keys(newData[0]);
      }
      this.setAttribute('data', JSON.stringify(newData));
      this.render();
    }
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'data' && oldValue !== newValue) {
      try {
        const parsedData = JSON.parse(newValue);
        if (Array.isArray(parsedData)) {
          this._data = parsedData;
          this._filteredData = [...parsedData];
          if (parsedData.length > 0) {
            this._columns = Object.keys(parsedData[0]);
          }
          this.render();
        }
      } catch (e) {
        console.error('Invalid data provided to data-table');
      }
    }
  }

  connectedCallback() {
    this.addEventListeners();
  }

  addEventListeners() {
    const bindEvents = () => {
      const filterInput = this.shadowRoot.querySelector('.filter-input');
      if (filterInput) {
        filterInput.addEventListener('input', (e) => {
          const filterValue = e.target.value.toLowerCase();
          this._filteredData = this._data.filter(row => 
            Object.values(row).some(value => 
              String(value).toLowerCase().includes(filterValue)
            )
          );
          this.render();
        });
      }

      const table = this.shadowRoot.querySelector('table');
      if (table) {
        table.addEventListener('click', (e) => {
          const headerCell = e.target.closest('th');
          if (headerCell) {
            const column = headerCell.dataset.column;
            this.sortByColumn(column);
          }
        });
      }
    };

    bindEvents();
    this._bindEvents = bindEvents;
  }

  sortByColumn(column) {
    if (this._sortColumn === column) {
      this._sortDirection = this._sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
      this._sortColumn = column;
      this._sortDirection = 'asc';
    }

    this._filteredData.sort((a, b) => {
      const valueA = a[column];
      const valueB = b[column];
      
      if (typeof valueA === 'string') {
        return this._sortDirection === 'asc' 
          ? valueA.localeCompare(valueB)
          : valueB.localeCompare(valueA);
      }
      
      return this._sortDirection === 'asc' 
        ? valueA - valueB
        : valueB - valueA;
    });

    this.render();
  }

  formatValue(value, column) {
    if (typeof value === 'number') {
      // Format numbers with 2 decimal places
      return value.toFixed(2);
    }
    
    if (column.toLowerCase().includes('date')) {
      // Try to format dates
      try {
        return new Date(value).toLocaleDateString();
      } catch (e) {
        return value;
      }
    }

    if (typeof value === 'boolean') {
      return value ? 'Yes' : 'No';
    }

    return value;
  }

  formatColumnHeader(header) {
    // Convert camelCase or snake_case to Title Case with spaces
    return header
      .replace(/([A-Z])/g, ' $1') // Split camelCase
      .replace(/_/g, ' ') // Replace underscores with spaces
      .replace(/^./, str => str.toUpperCase()) // Capitalize first letter
      .trim();
  }

  getStatusClass(status) {
    if (typeof status !== 'string') return '';
    
    const statusMap = {
      'success': 'success',
      'failed': 'failed',
      'processing': 'processing',
      'pending': 'processing',
      'error': 'failed',
      'complete': 'success',
      'completed': 'success'
    };
    return statusMap[status.toLowerCase()] || '';
  }

  render() {
    const style = `
      <style>
        :host {
          display: block;
          font-family: system-ui, -apple-system, sans-serif;
        }
        
        .container {
          border: 1px solid #e2e8f0;
          border-radius: 8px;
          padding: 16px;
        }

        .header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 16px;
        }

        .filter-input {
          padding: 8px 12px;
          border: 1px solid #e2e8f0;
          border-radius: 6px;
          width: 200px;
        }

        table {
          width: 100%;
          border-collapse: collapse;
          overflow-x: auto;
          display: block;
        }

        th, td {
          padding: 12px;
          text-align: left;
          border-bottom: 1px solid #e2e8f0;
          min-width: 100px;
        }

        td {
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          max-width: 200px;
        }

        th {
          cursor: pointer;
          user-select: none;
          background: #f8fafc;
          position: sticky;
          top: 0;
        }

        th:hover {
          background-color: #f1f5f9;
        }

        .status-cell {
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .status-indicator {
          width: 8px;
          height: 8px;
          border-radius: 50%;
        }

        .success .status-indicator {
          background-color: #22c55e;
        }

        .failed .status-indicator {
          background-color: #ef4444;
        }

        .processing .status-indicator {
          background-color: #3b82f6;
        }

        .number {
          font-family: monospace;
          text-align: right;
        }

        .footer {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-top: 16px;
          font-size: 14px;
          color: #64748b;
        }

        .sort-indicator::after {
          content: '↕';
          margin-left: 4px;
          opacity: 0.5;
        }

        .sort-asc::after {
          content: '↑';
          opacity: 1;
        }

        .sort-desc::after {
          content: '↓';
          opacity: 1;
        }

        .empty-state {
          text-align: center;
          padding: 32px;
          color: #64748b;
        }
      </style>
    `;

    const getSortIndicatorClass = (column) => {
      if (this._sortColumn === column) {
        return this._sortDirection === 'asc' ? 'sort-asc' : 'sort-desc';
      }
      return 'sort-indicator';
    };

    const isNumber = (value) => typeof value === 'number' || !isNaN(parseFloat(value));

    const renderCell = (value, column) => {
      // Check if it's a status-like column
      if (column.toLowerCase().includes('status')) {
        return `
          <div class="status-cell ${this.getStatusClass(value)}">
            <span class="status-indicator"></span>
            ${value}
          </div>
        `;
      }

      // Format the value based on its type
      const formattedValue = this.formatValue(value, column);
      
      // Add specific styling for numbers
      if (isNumber(value)) {
        return `<div class="number">${formattedValue}</div>`;
      }

      return formattedValue;
    };

    const html = `
      <div class="container">
        <div class="header">
          <input type="text" class="filter-input" placeholder="Filter items...">
        </div>
        
        ${this._columns.length > 0 ? `
          <table>
            <thead>
              <tr>
                ${this._columns.map(column => `
                  <th data-column="${column}" class="${getSortIndicatorClass(column)}">
                    ${this.formatColumnHeader(column)}
                  </th>
                `).join('')}
              </tr>
            </thead>
            <tbody>
              ${this._filteredData.map(row => `
                <tr>
                  ${this._columns.map(column => `
                    <td>${renderCell(row[column], column)}</td>
                  `).join('')}
                </tr>
              `).join('')}
            </tbody>
          </table>
        ` : `
          <div class="empty-state">No data available</div>
        `}
        
        <div class="footer">
          <span>${this._filteredData.length} of ${this._data.length} row(s)</span>
        </div>
      </div>
    `;

    this.shadowRoot.innerHTML = style + html;

    if (this._bindEvents) {
      this._bindEvents();
    }
  }
}

customElements.define('data-table', DataTable);
